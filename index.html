<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<title>BTF | ETF</title>
		<style></style>
	</head>

	<body>
		<canvas id="gameCanvas" width="screen.width" height="screen.height"></canvas>
		<img id="coinPos1" width="10" height="10" src="./coinPos1.jpg" alt="coinPos1" />
		<img id="coinPos2" width="10" height="10" src="./coinPos2.jpg" alt="coinPos2" />
		<img id="coinPos3" width="10" height="10" src="./coinPos3.jpg" alt="coinPos3" />
		<img id="coinPos4" width="10" height="10" src="./coinPos4.jpg" alt="coinPos4" />
		<img id="coinPos5" width="10" height="10" src="./coinPos5.jpg" alt="coinPos5" />
		<img id="coinPos6" width="10" height="10" src="./coinPos6.jpg" alt="coinPos6" />
		<img id="coinPos7" width="10" height="10" src="./coinPos7.jpg" alt="coinPos7" />
		<img id="coinPos8" width="10" height="10" src="./coinPos8.jpg" alt="coinPos8" />
		<img id="coinPos9" width="10" height="10" src="./coinPos9.jpg" alt="coinPos9" />

		<script>
			const FPS = 30; // frames per second
			const FRICTION = 0.7; // friction coefficient of space (0 = none, 1 = lots)
			const SHIP_SIZE = 30; // in pixels
			const SHIP_THRUST = 5; // acceleration in pixels per second^2
			const TURN_SPEED = 360; // turn speed in degrees per second
			let SCORE = 0;
			let TIME = 0;
			let choice = 'coinPos1';

			// get canvas properties
			var canvas = document.getElementById('gameCanvas');
			var context = canvas.getContext('2d');

			// set up the spaceship object
			var ship = {
				x: canvas.width / 2,
				y: canvas.height / 2,
				r: SHIP_SIZE / 2,
				a: (90 / 180) * Math.PI, // convert to radians
				rotation: 0,
				thrusting: false,
				thrust: {
					x: 0,
					y: 0,
				},
			};

			// event handlers
			document.addEventListener('keydown', keyDown);
			document.addEventListener('keyup', keyUp);

			// update loop
			setInterval(update, 1000 / FPS);

			function keyDown(/** @type {KeyboardEvent} */ ev) {
				switch (ev.keyCode) {
					case 37: // left arrow (rotate ship left)
						ship.rotation = ((TURN_SPEED / 180) * Math.PI) / FPS;
						break;
					case 38: // up arrow (thrust the ship forward)
						ship.thrusting = true;
						break;
					case 39: // right arrow (rotate ship right)
						ship.rotation = ((-TURN_SPEED / 180) * Math.PI) / FPS;
						break;
				}
			}

			function keyUp(/** @type {KeyboardEvent} */ ev) {
				switch (ev.keyCode) {
					case 37: // left arrow (stop rotating left)
						ship.rotation = 0;
						break;
					case 38: // up arrow (stop thrusting)
						ship.thrusting = false;
						break;
					case 39: // right arrow (stop rotating right)
						ship.rotation = 0;
						break;
				}
			}

			function update() {
				context.canvas.width = window.innerWidth;
				context.canvas.height = window.innerHeight;
				// draw space
				context.fillStyle = 'white';
				context.fillRect(0, 0, canvas.width, canvas.height);

				// thrust the ship
				if (ship.thrusting) {
					ship.thrust.x += (SHIP_THRUST * Math.cos(ship.a)) / FPS;
					ship.thrust.y -= (SHIP_THRUST * Math.sin(ship.a)) / FPS;

					// draw the thruster
					context.fillStyle = 'gold';
					context.strokeStyle = 'red';
					context.lineWidth = SHIP_SIZE / 10;
					context.beginPath();
					context.moveTo(
						// rear left
						ship.x - ship.r * ((2 / 3) * Math.cos(ship.a) + 0.5 * Math.sin(ship.a)),
						ship.y + ship.r * ((2 / 3) * Math.sin(ship.a) - 0.5 * Math.cos(ship.a))
					);
					context.lineTo(
						// rear centre (behind the ship)
						ship.x - ((ship.r * 5) / 3) * Math.cos(ship.a),
						ship.y + ((ship.r * 5) / 3) * Math.sin(ship.a)
					);
					context.lineTo(
						// rear right
						ship.x - ship.r * ((2 / 3) * Math.cos(ship.a) - 0.5 * Math.sin(ship.a)),
						ship.y + ship.r * ((2 / 3) * Math.sin(ship.a) + 0.5 * Math.cos(ship.a))
					);
					context.closePath();
					context.fill();
					context.stroke();
				} else {
					// apply friction (slow the ship down when not thrusting)
					ship.thrust.x -= (FRICTION * ship.thrust.x) / FPS;
					ship.thrust.y -= (FRICTION * ship.thrust.y) / FPS;
				}

				// draw ship
				context.strokeStyle = 'black';
				context.lineWidth = SHIP_SIZE / 20;
				context.beginPath();
				context.moveTo(
					// nose of ship
					ship.x + (4 / 3) * ship.r * Math.cos(ship.a),
					ship.y - (4 / 3) * ship.r * Math.sin(ship.a)
				);
				context.lineTo(
					// rear left
					ship.x - ship.r * ((2 / 3) * Math.cos(ship.a) + Math.sin(ship.a)),
					ship.y + ship.r * ((2 / 3) * Math.sin(ship.a) - Math.cos(ship.a))
				);
				context.lineTo(
					// rear right
					ship.x - ship.r * ((2 / 3) * Math.cos(ship.a) - Math.sin(ship.a)),
					ship.y + ship.r * ((2 / 3) * Math.sin(ship.a) + Math.cos(ship.a))
				);
				context.closePath();
				context.stroke();

				// rotate ship
				ship.a += ship.rotation;

				// move ship
				ship.x += ship.thrust.x;
				ship.y += ship.thrust.y;

				// handle edge of screen
				if (ship.x < 0 - ship.r) {
					ship.x = canvas.width + ship.r;
				} else if (ship.x > canvas.width + ship.r) {
					ship.x = 0 - ship.r;
				}
				if (ship.y < 0 - ship.r) {
					ship.y = canvas.height + ship.r;
				} else if (ship.y > canvas.height + ship.r) {
					ship.y = 0 - ship.r;
				}

				if (Math.abs(ship.x - context.canvas.width / 2) < 100 && Math.abs(ship.y - context.canvas.height / 2) < 100) {
					SCORE++;
					console.log('hti');
				}

				if (TIME == 4) {
					if (choice == 'coinPos1') choice = 'coinPos2';
					else if (choice == 'coinPos2') choice = 'coinPos3';
					else if (choice == 'coinPos3') choice = 'coinPos4';
					else if (choice == 'coinPos4') choice = 'coinPos5';
					else if (choice == 'coinPos5') choice = 'coinPos6';
					else if (choice == 'coinPos6') choice = 'coinPos7';
					else if (choice == 'coinPos7') choice = 'coinPos8';
					else if (choice == 'coinPos8') choice = 'coinPos9';
					else if (choice == 'coinPos9') choice = 'coinPos1';
					TIME = 0;
				}
				TIME++;
				context.fillStyle = 'black';
				context.font = '50px san-serif';

				context.fillText(SCORE, context.canvas.width / 20, context.canvas.height / 5);
				var img = document.getElementById(choice);
				context.drawImage(img, context.canvas.width / 2, context.canvas.height / 2);
			}
		</script>
	</body>
</html>
